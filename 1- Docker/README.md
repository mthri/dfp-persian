<div dir="rtl">

# داکر

با وجود تمامی پیشرفت ها در برنامه نویسی مدرن، پیکربندی اصولی یک محیط توسعه محلی همچنان یک چالش بزرگ است. در یک پروژه فاکتورهای متعددی از قبیل کامپیوتر های مختلف، سیستم عامل های مختلف، نسخه های گوناگون جنگو، موارد مختلفی از یک محیط مجازی و غیره وجود دارد. اما چالش زمانی بزرگتر میشود که باید در یک محیط تیمی کار کنیم که همه افراد به پیکربندی یکسانی [از محیط توسعه] نیاز دارند.

راه حلی بنام **داکر** در سالهای اخیر پدیدار شده است. اگر چه عمری از پیدایش آن نمیگذرد، اما بسرعت تبدیل به گزینه ی اصلی برای توسعه دهندگانی شد که در سطح تولید کار میکنند. سرانجام، با استفاده از داکر میتوان یک محیط توسعه ی محلی قابل اعتماد و منسجمی بوجود آورد که از ورژن مدنظر پایتون و نصب جنگو گرفته تا سرویس های مازادی در کنار آنها نظیر پایگاه داده ها را شامل میشود. این به این معناست که دیگر مهم نیست شما از چه سیستم عاملی (مک، لینوکس، ویندوز) استفاده میکنید، چراکه همه چیز در خود داکر در حال اجراست. همچنین داکر همکاری در محیط های تیمی را رفته رفته آسان تر میکند. آن زمان که از فایل های طولانی و قدیمی README برای افزودن یه محیط توسعه جدید در پروژه های گروهی استفاده میکردیم دیگر گذشته است. در عوض داکر این امکان را میدهد که به سادگی دو فایل Dockerfile و docker-compose.yml را به اشتراک بگذارید و توسعه دهنده میتواند اطمینان داشته باشد که محیط توسعه محلی او همانند سایر اعضای تیم است.

داکر یک فناوری کامل نیست و نسبتا نوپا است که زیر ساخت های آن در حال توسعه هستند. اما میتوان این نوید را داد که یک محیط توسعه سازگار و قابل اشتراک است که قادر است بصورت محلی روی هر رایانه یا سروری اجرا شود که همین موضوع آن را به انتخابی مناسب تبدیل میکند. در این فصل، کمی بیشتر درباره داکر و داکرایز کردن (dockerize) اولین پروژه جنگو می آموزیم.

پ.ن: داکرایز: پیکربندی داکر متناسب با پروژه و همگام سازی آنها با یکدیگر

### داکر چیست؟

داکر ابزاری است که سیستم عامل نصبی روی سیستم شما را بوسیله کانتینر های لینوکسی از سایر اجزا مجزا میکند. این روشی برای مجازی سازی میباشد.

پ.ن: قبل از آشنایی با کانتینر ها(containers)، ابتدا باید مفهوم image را درک کنیم.

ریشه مجازی سازی به ابتدای علوم کامیوتر برمیگردد، زمانی که ابر کامپیوتر ها رایج بودند. این سوال بوجود آمد که "چند برنامه نویس چگونه میتوانند از یک رایانه بطور همزمان استفاده کنند؟" پاسخ، مجازی سازی بود؛ بالاخص ماشین های مجازی که نسخه کاملی از کامپیوتر ها به همراه سیستم عامل آنها بود.

اگر شما یک فضای ابری در سرویس های ارائه دهنده مثل آمازون تهیه کنید، این چنین نیست که یک سخت افزار اختصاصی به شما ارائه دهند. در عوض شما هستید که یک سرور فیزیکی را با سایر مشتریان به اشتراک میگذارید. اما چونکه مشتریان ماشین های مجازی خود را روی سرور آمازون اجرا میکنند، بنظر میرسد هرکس برای خودش یک سرور اختصاصی دارد. این فناوری امکان افزودن یا حذف سرور از فضای ابری را ممکن میسازد. این فناوری تا حدی بسیار زیادی توسط نرم افزار ها پشتیبانی میشوند و سخت افزار ها بطور کامل در این تغییرات دخیل نیستند.

و اما! نقطه ضعف ماشین های مجازی چیست؟ اندازه و سرعت دو تا از چالش های هستند. یک سیستم عامل معمولی به راحتی میتواند ۷۰۰ مگابایت حجم داشته باشد. بنابراین اگر یک سرور فیزیکی از سه ماشین مجازی (۳×۷۰۰) پشتیبانی کند، ۲.۱ گیگابایت از فضای دیسک بعلاوه ی نیاز های سی پی یو . منابع حافظه اشغال میشود.

خوب راه حل چیست؟ از داکر استفاده کنید. ایده اصلی این است که اکثر رایانه ها از یک سیستم عامل لینوکس استفاده میکنند. حال اگر مجازی سازی را از لایه های بالایی لینوکس شروع کنیم چه میشود؟ (منظور این است که از هسته اصلی لینوکس شروع نکنیم) آیا حجم کمتر و سرعت بیشتری ارائه نمیشود. راه حلی برای تکرار عملکرد های مشابه در پروژه است؟ پاسخ بله است. راه حل این چالش ها کانتینر های لینوکسی هستند که در سالهای اخیر بسیار محبوب شده اند. برای برنامه نویس ها بویژه وب اپلیکیشن ها (همچون جنگو) ماشین های مجازی و کانتینر های لینوکسی منابعی بیش از آنچه که نیاز است ارائه میدهند. این اساسا همان چیزی است که داکر ارائه میدهد: راهی برای پیاده سازی کانتینر های لینوکسی.

بهترین تشبیهی که میتوانیم اینجا بکار ببریم، محله و آپارتمان هستند. فرض کنید ماشین مجازی همان محله است. در هر محله ساختمان های مجزا از هم با زیر ساخت های خاص خود وجود دارد. از جمله لوله کشی، سیستم گرمایش، حمام و آشپزخانه. کانتینر های ماشین مجازی همان ساختمان ها هستند که در لوله کشی و سیستم گرمایش مشترک هستند، اما ظرفیت هر کدام از این بخش ها در ساختمان های مختلف بسته به نیاز مالک ساختمان و تعداد خانوار ها متفاوت است.

### کانتینر ها (containers) در مقایسه با محیط های مجازی

شما بایستی از قبل بعنوان یک برنامه نویس پایتون با مفهوم محیط های مجازی که راهی برای ایزوله کردن پکیج های پایتونی هستند آشنا باشید. جا داره از این محیط مجازی یه تشکری کنیم (: با وجود محیط مجازی در یک کامپیوتر میتوانیم بصورت محلی چند پروژه را اجرا کنیم. مثلا: فرض کنید یک پروژه از پایتون نسخه ۳.۴ و جنگو ۱.۱۱ استفاده میکند، در حالی که پروژه دیگر از پایتون ۳.۸ و جنگو ۳.۱ بهره گرفته است. با ایجاد یک محیط مجازی اختصاصی برای هر یک از این دو پروژه میتوان پکیج های متفاوت را در حین آلوده نکردن سیستم کامپیوتری [که بخاطر نصب نسخه های مختلف از یک پکیج ایجاد میشوند] مدیریت کرد.

در حال حاضر، چند ابزار محبوب برای پیاده سازی محیط مجازی وجود دارد:

- `venv`
- `pipenv`
- `virtualenv`

اما اساسا همه اینها یک کار انجام میدهند.
مهم ترین فرق بین محیط های مجازی و داکر این است که، محیط های مجازی فقط میتوانند از پکیج های پایتونی پشتیبانی کنند. مثلا قابلیت نصب برنامه هایی که پایتونی نیستند (مثل PostgreSQL یا MySQL) ندارند. چرا که این برنامه ها بایستی در سیستم اصلی کامپیوتر شما بصورت محلی نصب باشند. به بیانی دیگر، محیط های مجازی فقط و فقط به اشاره به پایتون و هر آنچه که از جنس پایتون است دارد و خود به تنهایی شامل این موارد نیست.

کانتینر های لینوکسی یک قدم فرا تر رفته، نه فقط بخش های مربوط به پایتون را بلکه کل سیستم عامل و هر چیزی که در آن نصب است را تفکیک میکند. مثلا هم میتوان پایتون و موارد مربوط به نوع دیتا بیس [از قبیل MySQL] را در داکر نصب و اجرا کنیم.

داکر به خودی خود موضوعی پیچیده است و ما در این کتاب عمیقا آن را برسی نمیکنیم. درک مفاهیم اولیه و نکات کلیدی آن مهم است. اگر میخواهید در این باره بیشتر بدانید، توصیه میکنم سری به [Dive into Docker video course](https://diveintodocker.com/ref-dfp) بزنید (:

### نصب داکر

خوب خوب، دیگه تئوریجات کافیه. بیاد که داکر و جنگو را در کنار هم استفاده کنیم. قدم اول ثبت نام در سایت [داکر هاب](https://hub.docker.com/signup) و نصب نسخه ی دسکتاپ داکر بر روی سیستم است.

از طریق این لینک ها میتوانید داکر را نصب کنید:

- [داکر برای مک](https://docs.docker.com/desktop/mac/install/)
- [داکر برای لینوکس](https://docs.docker.com/desktop/windows/install/)
- [داکر برای ویندوز](https://docs.docker.com/engine/install/)

از آنجایی که فایل نصبی حجیم است، دانلود ممکن است کمی طول بکشد. در این مرحله با خیال راحت دراز بکشین (:
لازم به ذکر است داکر در نسخه لینوکس از یوزر root استفاده میکند که این موضوع اغلب ایده آل نیست. در صورت تمایل میتوانید داکر را طوری تنظیم کنید که به عنوان یوزر غیر root اجرا شود.

وقتی که داکر نصب شد با اجرای دستور docker --version در cmd میتوانیم ورژن در حال اجرای داکر را تایید کنیم. ورژن داکر حداقل باید ۱۸ باشد.

<div dir="ltr">

```shell
$ docker --version
# Docker version 19.03.12, build 48a66213f
```

</div>

بعضی اوقات داکر از یک ابزار جانبی به اسم [Docker Compose](https://docs.docker.com/compose/) برای کمک به اجرای خودکار دستورات استفاده میشود.
Docker Compose را برای مک و ویندوز میتوانید دانلود کنید اما اگر از لینوکس استفاده میکنید، بایستی به صورت دستی آنرا نصب کنید. این کار را میتوانید با اجرای دستور `sudo pip install docker-compose` پس اینکه نصب داکر تمام شد انجام دهید.

#### Hello World

داکر یک image مخصوص خود به اسم "Hello, World" دارد که به عنوان اولین اجرا میتواند مفید باشد. در cmd، `docker run hello-world` را اجرا کنید. این دستور image رسمی داکر را دانلود و سپس در قالب یک کانتینر اجرا میکند. درباره image و container (کانتینر) جلوتر صحبت میکنیم (:

<div dir="ltr">

```shell
$ docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete
Digest: sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00
Status: Downloaded newer image for hello-world:latest
Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.
To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID:
https://hub.docker.com/
For more examples and ideas, visit:
https://docs.docker.com/get-started/
```

</div>

دستور `docker info` به ما این امکان را میدهد تا به آنچه که در داکر هست سرک بکشیم. این دستور خروجی های زیادی را نمایش میدهد اما خطوط اول که نشان میدهد ما یک container متوقف شده و یک image داریم برایمان حائز اهمیت است.

<div dir="ltr">

```shell
$ docker info
Client:
Debug Mode: false
Server:
Containers: 1
Running: 0
Paused: 0
Stopped: 1
Images: 1
...
```

</div>

تمامی این خطوط نشان میدهد داکر با موفقیت نصب شده و در حال اجراست.

### جنگو Hello World

هم اکنون یه پروژه جنگو به اسم `Hello World` درست میکنیم که روی سیستم شما اجرا میشود و آن را به داکر منتقل میکنیم و میبینیم که چطور همه چیز با هم درست کار میکند.

اولین قدم انتخاب یه مکان برای قرار دادن کد ها میباشد. این قسمت میتواند هر قسمتی از سیستم شما باشد. اما اگر از مک استفاده میکنید، راه ساده آن استفاده از Desktop میباشد. از طریق کامند لاین وارد `Desktop` شوید و یک پوشه به اسم `code` بسازید. تمام مثال ها و پروژه های داخل این پوشه قرار داده میشود.

<div dir="ltr">

```shell
$ cd Desktop
$ mkdir code && cd code
```

</div>

برای این مثال یک پوشه اسم `hello` درست کنید و با استفاده از `pipenv` جنگو را نصب کنید که دو فایل `Pipfile` و `Pipfile.lock` میسازد. با دستور `pipenv shell` محیط مجازی را فعال کنید

<div dir="ltr">

```shell
$ mkdir hello && cd hello
$ pipenv install django=3.1.0
$ pipenv shell
(hello) $
```

</div>

با استفاده از دستور `startproject` یک پروژه جنگو به اسم `config` درست میکنیم. `.` در آخر دستور یک قسمت اختیاری میباشد که بیشتر توسعه دهندگان جنگو استفاده میکنند. قرار نگرفتن آن، چند فایل اضافه درست میکند که با استفاده از آن این فایل ها صاخته نمیشوند.

با استفاده از دستور `migrate` دیتابیس و را میسازیم و پروژه را با `runserver` اجرا میکنیم.

<div dir="ltr">

```shell
(hello) $ django-admin startproject config .
(hello) $ python3 manage.py migrate
(hello) $ python3 manage.py runserver
```

</div>

با در نظر گرفتن این که همه چیز درست کار میکند، وارد `http://127.0.0.1:8000` با یک مرورگر شوید و صفحه خوش آمد گویی جنگو را مشاهده کنید.

### اپ pages 

هم اکنون ما یک صفحه اصلی ساده به همراه یک اپ اختصاصی `pages` برای ان ایجاد میکنیم . با تایپ کردن `Control+c` سرور را متوقف کنید و برای اضافه کردن نام مورد نظر ما `pages` از دستور `.startapp` استفاده کنید .

<div dir="ltr">

```shell
(hello) $ python manage.py startapp pages
```

</div>

جنگو به طور خودکار یک پوشه جدید `pages` و فایل هایی برای ما ایجاد میکند . اما حتی اگر برنامه ما ایجاد شده باشد  `config` تا زمانی که آن را به `INSTALLED_APPS` اضافه نکنیم نمیتواند بشناسد  . config در داخل فایل  `config/settings.py` قرار دارد . جنگو اپ ها را از بالا به پایین بارگذاری میکند بنابراین به طور کلی ، افزودن برنامه های جدید به برنامه های داخلی که ممکن است به آنها وابسته باشند مانند `admin`و `auth`  و بقیه ، یک عمل خوب است . 

<div dir="ltr">

```python
# config/settings.py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'pages', # new
]
```

</div>

اکنون ما میتوانیم مسیر url را برای اپ pages تنظیم کنیم . از آنجا که میخواهیم پیام ما در صفحه اصلی ظاهر شود از رشته خالی "" استفاده میکنیم . همچنین فراموش نکنید که در خط دوم include را import کنید .

<div dir="ltr">

```python
# config/urls.py
from django.contrib import admin
from django.urls import path, include # new

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('pages.urls')), # new
]
```

</div>

در این مرحله به جای تنظیم یک قالب میتوانیم یک پیام هارد کد (hardcode) در فایل ویو در `pages/views.py` که خروجی رشته می دهد "Hello, World!" انجام بدهیم .

<div dir="ltr">

```python
# pages/views.py
from django.http import HttpResponse

def home_page_view(request):
    return HttpResponse('Hello, World!')
```

</div>

بعدی چیست ؟ ما آخرین مرحله یک فایل `urls.py` در اپ `pages` ایجاد کردیم و ان را به `home_page_view` متصل کردیم . اگر از سیستم عامل  Mac یا Linux استفاده می کنید از دستور touch در خط فرمان میتوان برای ایجاد فایل های جدید استفاده کرد . در سیستم عامل Windows میتوان برای ایجاد فایل جدید از ویرایشگر متن استفاده کرد . 

<div dir="ltr">

```shell
(hello) $ touch pages/urls.py
```

</div>

در ویرایشگر متن خود path را در بالای خط import کنید , `home_page_view` را اضافه کنید  ,و سپس مسیر را طوری تنظیم کنید که دوباره رشته خالی "" باشد. توجه داشته باشید که ما همچنان برای این مسیر یک نام اختیاری `home` را مینویسیم که بهترین کار است .

<div dir="ltr">

```python
# pages/urls.py
from django.urls import path
from .views import home_page_view

urlpatterns = [
    path('', home_page_view, name='home')
]
```

</div>

جریان کامل از صفحه نخست جنگو ما به شرح زیر است :

* * هنگامی که یک کاربر به صفحه اصلی می رود ابتدا به مسیر `config/urls.py` هدایت می شود .  سپس به مسیر `pages/urls.py` هدایت می شود . * و در نهایت به  home_page_view هدابت می شوید که رشته "Hello, World" را بر میگرداند .

کار ما برای صفحه نخست تمام شده است . سرور را دوباره راه اندازی کنید .

<div dir="ltr">

```shell
(hello) $ python manage.py runserver
```

</div>

اگر شما مروگر وب را در آدرس `http://127.0.0.1:8000` رفرش (refresh) کنید اکنون پیام مورد نظر ما را ارسال می کند .

اکنون وقت آن است که به سراغ docker بروید . سرور را دوباره با `Control+c` متوقف کرده و از محیط مجازی خود با نوشتن exit خارج شوید زیرا دیگر نیازی به آن نیست .

<div dir="ltr">

```shell
(hello) $ exit
$
```

</div>

چگونه میتوانیم بفهمیم که دیگر محیط مجازی فعال نیست ؟  دیگر هیچ پرانتزی در اطراف نام دایرکتوری خط فرمان (command line) وجود نخواهد داشت . هر دستور عادی جنگو که سعی کنید در این مرحله اجرا کنید ارور می دهد . به عنوان مثال , دستور `python manage.py runserver` را امتحان کنید تا ببینید چه اتفاقی می افتد .

<div dir="ltr">

```shell
$ python manage.py runserver
File "./manage.py", line 14
    ) from exc
        ^
SyntaxError: invalid syntax
```

</div>

این بدان معناست که ما کاملا از محیط مجازی خارج شده ایم و حاضر و آماده برای Docker هستیم .

### ایمیج ها، کانتینر ها و میزبانی داکر

یک ایمیج داکر محتوای فوری یک پروژه میباشد. ایمیج های داکر با فایلی به نام `Dockerfile` اجرا میشوند که شامل دستور عمل های یک ایمیج میباشد. یک کانتینر به عنوان مثال ه ایمیج داکر اجرا میشود. به مثال آپارتمان بر میگردیم، ایمیج یک طرح یا مجموعه ای از طرح های آپارتمان است. کانتینر هم ساختمان واقعی و کاملا ساخته شده است.

سومین مفهموم، میزبانی داکر است که سیستم عاملی اساسی است. حتی ممکن هست شما چند کانتینر توسط میزبان داکر اجرا کنید.  وقتی میخواهیم توسط داکر کد بزنیم یا روندی را انجام دهیم، یعنی آنها توسط میزبانی داکر اجرا میشوند.

اولین `Dockerfile` خودمون رو میسازیم و این عملیات رو مشاهده می کنیم.

<div dir="ltr">

```shell
$ touch Dockerfile
```

</div>

حالا کد های زیر رو بهش اضافه کنید تا درباره آنها خط به خط صحبت کنیم.

<div dir="ltr">

```docker
# Pull base image
FROM python:3.8
# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1
# Set work directory
WORKDIR /code
# Install dependencies
COPY Pipfile Pipfile.lock /code/
RUN pip install pipenv && pipenv install --system
# Copy project
COPY . /code/
```

</div>

همچنین `Dockerfile` از بالا به پایین وقتی ایمیج ساخته میشود خوانده میشوند. اولین قسمت باید دستور `FROM` باشد تا ایمیج اصلی را برای ایمیج ما فراخوانی کند. این بار، `Python 3.8`.

سپس از دستور `ENV` برای تعریف دو محیط استفاده میکنیم.

- `PYTHONUNBUFFERED` اطمینان می دهد که خروجی کنسول ما آشنا به نظر می رسد و توسط داکر بافر نمی شود ،
که ما نمی خواهیم.
- `PYTHONDONTWRITEBYTECODE` به این معنی که پایتون سعی نمی کند فایل های .pyc بنویسد که ما نیز انجام می دهیم
میل ندارد.

مرحله بعد استفاده از `WORKDIR` برای تنظیم مسیر پیش فرض فهرست کار در ایمیج خود به نام `code` که کد است استفاده می کنیم
جایی که ما کد خود را ذخیره می کنیم اگر این کار را نکردیم ، هر بار می خواستیم دستورات را اجرا کنیم
کانتینر ها باید در مسیری طولانی تایپ کنیم. در عوض، داکر فرض میکند که ما میخواهیم تمام دستورات را داخل پوشه اجرا کنیم.

برای وابستگی ها، از `Pipenv` استفاده میکنیم. پس دو فایل `Pipfile` و `Pipfile.lock` را داخل پوشه `code` داخل داکر کپی میکنیم.

ارزش داره که توضیح بدیم که چرا `Pipenv` فایل `Pipfile.lock` را درست میکند.  مفهمون فایل های `lock` هنوز یونیک نیست داخل پایتون و `Pipenv`. در واقع در پکیج منیجر ها قابل مشاهده است برای زبان های محبوب. مثل `Gemfile.lock` رو روبی، `yarn.lock` در جاوا اسکریپت، `composer.lock` در php و غیره. `Pipenv` اولین و محبوب ترین پروژه ای بود که این ها را داخل پایتون قرار داد.

مزایای فایل `lock` این هست که منجر به نصب کامل میشوند. مهم نیست چند بار پکیج را نصب میکنید، همیشه نتیجه یکسان خواهد بود. بدون این فایل ها وابستگی ها و ترتیب ها اینطور نیست. اعضای تیمی که لیست یکسانی از بسته های نرم افزاری را نصب می کنند ممکن است ساختار کمی متفاوت داشته باشند.

وقتی که از داکر استفاده میکنیم، چه در سیستم شخصی و چه در جای دیگه، و بروزسانی بسته های نرم افزاری، احتمال درگیری `Pipfile.lock` بوجود می آید. در فصل بعد این موضوع را بررسی میکنیم.

برگردیم، ما از دستور `RUN` استفاده کردیم که اول Pipenv را نصب کنیم تا `Pipenv` پکیج های لیست شده داخل `Pipfile.lock` را نصب کند. فعلا فقط جنگو. خیلی مهم هست که از `system--` استفاده کنید تا `Pipenv` یک محیط مجازی را درست کند. اما ولی از داکر استفاده میکنیم نیازی به محیط مجازی نیست.

در این حالت، کانتینر داکر ما محیط مجازی و موارد دیگر ما میباشد. بنابر این از `system--` استفاده میشود تا مطمئن شویم که بسته های ما در تمام سیستم نصب میشود. برای آخرین مرحله ما پوشه code خود را به پوشه code داکر انتقال میدهیم. ابتدا `Pipfile.lock` و `Pipfile` و بعد بقیه را؟

دلیل این است که ایمیج بر اساس دستورالعمل های بالا به پایین ایجاد می شوند، بنابراین ما می خواهیم چیزهایی که اغلب تغییر می کنند مانند کد محلی ماآخرین باشند. به این ترتیب ما فقط باید آن قسمت از ایمیج را هنگام تغییر ایجاد کنیم، نه اینکه هر بار که تغییری رخ می دهد همه چیز را دوباره نصب کنیم. و از آنجا که بسته های نرم افزاری موجود در `Pipfile` و `Pipfile.lock` ما به ندرت تغییر می کنند ، منطقی است که آنها را کپی کرده و زودتر نصب کنیم.

دستورالعمل های ایمیج ما اکنون انجام شده است ، بنابراین اجازه دهید image را با استفاده از دستور `docker build` بسازیم. نقطه ،`.` ، نشان می دهد که فهرست فعلی محل اجرای دستور است. در اینجا خروجی زیادی وجود خواهد داشت. به همین دلیل فقط چند خط آن را وارد کردم.

<div dir="ltr">

```shell
$ docker build .
Sending build context to Docker daemon
Step 1/7 : FROM python:3.8
3.8: Pulling from library/python
...
Successfully built 8d85b5d5f5f6
```

</div>

نیاز هست یک فایل به اسم `docker-compose.yml` ساخته شود تا کنترل روی اجرای کانتینر انجام شود که روی بر پایه ایمیج `Dockerfile` هست.

<div dir="ltr">

```shell
$ touch docker-compose.yml
```

</div>

فایل ما شامل کد های زیر میشود.

<div dir="ltr">

```yml
version: '3.8'

services:
    web:
        build: .
        command: python /code/manage.py runserver 0.0.0.0:8000
        volumes:
        - .:/code
        ports:
        - 8000:8000
```

</div>

در خط بالا ما ورژن داکر را مشخص میکنیم که در حال حاضر 3.8 میباشد. با ورژن حال پایتون که 3.8 هست اشتباه نگیرید. کاملا تصادفی است!

سپس اطلاعات کانتینر را مشخص میکنیم که در داکر هاست اجرا میشود. امکان اجرای چند کانتینر نیز وجود دارد اما ولی فعلا یک کانتینر را توضیح میدهیم. مشخص میکنیم که کانتینر چطور ساخته. به پوشه فعلی `.` نگاه کن برای `Dockerfile`.بعد داهل کانتینر وب سرور را اجرا کن.

ظرفیت پایه به صورت خودکار فایل داکر را توسط کامپیوتر ما همگام می سازد  . این به این معنی است که ما نیاز نداریم هر زمان که یک فایل را تغیر می دهیم , `image` را دوباره بسازیم .

در آخر ما `پورت` خروجی را در داکر مشخص میکنیم که پورت `8000` خواهد بود که همان پورت دیفالت جنگو میباشد.

اگر اولین بار است که از docker استفاده می کنید , به احتمال زیاد الان سردرگم شده اید . اما نگران نباشید . ما چندین ایمیج داکر و کانتینر ها (containers) در طول فصل های این کتاب خواهیم ساخت که با تمرین کردن مهارت لازم را به دست می آورید . شما خواهید دید که چندین Dockerfile و docker-compose.yml مشابه در پروژه ها استفاده می کنیم .

قدم آخر هم اجرای دستور `docker-compose up` میباشد. این دستور باعث یک خروجی طولانی دیگر در کامند لاین می‌شود.

<div dir="ltr">

```shell
$ docker-compose up
Creating network "hello_default" with the default driver
Building web
Step 1/7 : FROM python:3.8
...
Creating hello_web_1 ... done
Attaching to hello_web_1
web_1 | Watching for file changes with StatReloader
web_1 | Performing system checks...
web_1 |
web_1 | System check identified no issues (0 silenced).
web_1 | August 03, 2020 - 19:28:08
web_1 | Django version 3.1, using settings 'config.settings'
web_1 | Starting development server at http://0.0.0.0:8000/
web_1 | Quit the server with CONTROL-C.
```

</div>

برای صحت این که کار میکند داخل مرورگر وارد `127.0.0.1:8000` شوید، صفحه را رفرش کنید و صفحه `Hello, World` باید نشان داده شود. جنگو هم اکنون با داکر اجرا میشود. ما در یک محیط مجازی کار نمیکنیم. ما حتی دستور `runserver` را هم اجرا نکردیم. تمام کار های پروژه روی یک وب سرور مستقل داکر اجرا میشود. موفقیت!

برای متوقف کردن کانتینر، کنترل و سی را هم زمان بفشارید و دستور `docker-composer down` را اجرا کنید. کانتینر های داکر حجم زیادی از مموری را میگیرد، پس ایده خوبی هست که آنها را متوقف کنیم. آنها بی تابعیت هستند و به همین هست که ما از `volumes` برای کپی کردن کد ها روی محیطی که میتوان استفاده کرد، استفاده کردیم.

<div dir="ltr">

```shell
$ docker-compose down
Removing hello_web_1 ... done
Removing network hello_default
```

</div>

### گیت

گیت یک سیستم کنترل ورژن امروزی هست که در این کتاب استفاده میکنیم. در ابتدا یه فایل گیت با `git init` میسازیم، تغییرات را مشاهده میکنیم و وقتی آنها را ثبت میکنیم.

<div dir="ltr">

```shell
$ git init
$ git status
$ git add .
$ git commit -m "ch1"
```

</div>

حالا با [پروژه اصلی این فصل داخل گیتهاب](https://github.com/wsvincent/djangoforprofessionals/tree/master/ch3-books) پروژه خود را مقایسه کنید.

### نتیجه گیری

داکر یه محیط کاملا مستقل شامل تمام چیزایی هست که ما برای توسعه لوکال نیاز داریم. وب سرویس، دیتابیس و حتی بیشتر. الگو کلی یک پروژه جنگو یکسان میباشد.

- ساخت محیط مجازی و نصب جنگو
- ساخت پروژه
- خروج از محیط مجازی
- نوشتن `Dockerfile` و ساخت ایمیج
- ساخت `docker-compose.yml` و اجرا با دستور `docker-compose up`

ما چند پروژه جنگو با داکر باز میسازیم. پس این جریان منطقی تر به نظر میرسد. در فصل بعد یک پروژه جنگو با داکر و PostgreSQL در یک کانتینر جدا به عنوان دیتابیس میسازیم.
