<div dir='rtl' align='right'>

# فصل شانزدهم: امنیت 

دنیای اینترنت، دنیای خطرناکی هست. در آن تعداد زیادی افراد بد حتی بیشتر از آنها ربات های هستند که بصورت خودکار تلاش میکنند وبسایت شما را هک و ایجاد مشکل کنند. از این رو فهمیدن و پیاده سازی فیچر های امنیتی در هر وبسایتی الزامی است.

خوشبختانه، جنگو به دلیل سال‌ها تجربه در رسیدگی به مسایل مربوط به امنیت وب و همچنین یک چرخه بروز رسانی امنیتی قوی از سابقه بسیار خوبی بر خوردار می‌باشد.

فیچر های جدید تقریبا هذ ۹ ماه یک بار مثل ورژن ۲.۲ تا ۳.۰ منتشر می‌شوند اما وصله های امنیتی تقریبا هر ماه بصورت ۲.۲.۲ تا ۲.۲.۳ منتشر می‌شوند.

به هرحال، مانند هر ابزاری، این مهم است که فیچر های امنیتی بطور صحیح پیاده سازی شوند و ما در این قسمت آموزش می‌دهیم که چطور این موراد امنیتی را در  پروژه کتاب فروشی (Book Store) پیاده سازی کنید.


## مهندسی اجتماعی (Social Engineering)

درنهایت بزرگترین ریسک برای هر وبسایتی مشکلات فنی نیست، مشکلات انسانی است!

اصطلاح مهندسی اجتماعی به مجموعه روش های پیدا کردن افراد با دسترسی به یک سیستم اشاره می‌کند که خواسته یا ناخواسته اطلاعات اهراز هویت خود را در اختیار فرد حمله کنند قرار میدهد (مترجم: فرد حمله کننده با اطلاعات فرد مورد اطمینان وارد سیستم می‌شود)

این روز ها بزرگترین مقصر، فیشنگ می‌باشد. همه این‌ها از یک کلیک بر روی لینک مخرب که در یک ایمیل قرار دارد شروع می‌شود که باعث می‌شود که دسترسی کارمند را به فرد هکر بدهد یا لااقل دسترسی اش را به خطر بیندازد.
 برای جلوگیری از این اتفاق (فیشنگ)، باید دسترسی های مختلف ایجاد کنید و به افراد فقط دسترسی هایی که به آن لازم دارن داده شود و نه بیشتر! آیا همه مهندسین احتیاج دسترسی بع دیتابیس محصول را دارند؟ احتمالا نه. آیا سایر کارمندان احتیاج به دسترسی نوشتن(در دیتابیس) را نیاز دارند؟ دوباره، احتمالا نه.
بهترین کار این است که بطور پیشفرض فقط دسترسی های مورد نیاز داده شود، نه اینکه پیشفرض همه را superuser درنظر بگیریم!

## بروزرسانی های جنگو (Django updates)
یکی از راه های مهم امن نگهداشتن پروژه شما، بروز نگهداشتن ورژن به آخرین ورژن جنگو می‌باشد. این به این معنی نیست که فقط به ورژن های آخرین بروزرسانی (latest feature release) مانند ورژن های ۲.۲، ۳.۰، ۳.۱ یا ... بروزرسانی کنید که حدودا هر ۹ ماه منتشر می‌شود. همچنین بروزرسانی های امنیتی هر ماه منتشر می‌شود که به صورت ۲.۲.۱، ۲.۲.۲، ۲.۲.۳ یا... منتشر می‌شوند.(مترجم: به این معنا می‌باشد که هر ماه باید بروز رسانی های امنیتی را دریافت کنید)

نسخه های(releases) long-term support یا به اختصار LTS چه هستند؟ بعضی از feature releases را LTS نامیده می‌شوند که برای مدت مشخصی (حدودا ۳ سال) اطمینان داده می‌شود که   بروزرسانی های امنیتی و data fixes را دریافت می‌کند. برای مثال ورژن ۲.۲ جنگو LTS هست که تا سال ۲۰۲۲ بروزرسانی می‌شوند، یعنی تا زمانی که نسخه ۴.۰ جنگو بعنوان ورژن بعد LTS انتخاب می‌شود. آیا می‌شود روی نسخه LTS ماند؟ بله. آیا مجبورید؟ نه. برای امن بودن بهتر هست همیشه بروز باشیم.

مقاومت در مقابل وسوسه(بروزرسانی) و واقعیت تعداد زیادی از پروژها این نیست که وقت توسعه را به رفع اشکالات بعد از بروزرسانی جنگو بگذارند. یک وبسایت همانند یک خودرو: نیاز به نگهداری منظم برای کار کردن در بهترین حالت خود را دارد. اگر  از خیر بروز رسانی ها بگزرید، تنها مشکلات را باهم ترکیب می کنید.

چگونه بروزرسانی کنیم؟ امکان deprecation warning جنگو، باید قبل از هر ریلیز با تایپ دستور `python -Wa manage.py test` اجرا شود. بهتر است برای بروزرسانی نسخه به نسخه  اقدام شود (مثلا از ۲.۰ به ۲.۱ بعد به ۲.۲ و الی آخر) و هر دفعه deprecation warning را اجرا کرد تا اینکه یک دفعه به نسخه آخر رفت.(چندین نسخه بین را بدون اجرا دستور گفته شده رد کردن)

## چک‌لیست استقرار (Deployment Checklist)
برای کمک به استقرار و بررسی های امنیتی، در مستندات جنگو یک چک‌لیست قرار گرفته است که بیشتر تنظیمات امنیتی در آن قرار گرفته است.

حتی بهتر از آن استفاده از  `python manage.py check --deploy` است که می‌توانیم توصیه های جنگو را دریافت کنیم و ببینیم آیا پروژه ما آماده استقرار است یا خیر. این دستور  از سیستم برسی فریم‌ورک(system check framework) جنگو استفاده میکند که می‌تواند برای سفارشی سازی دستورات مشابه در پروژه های بزرگ تر مورد استفاده قرار گیرد(مترجم: خودمم نفهمیدم چی گفت :) )

به دلیل اینکه ما داریم از داکر استفاده میکنیم باید دستور `docker-compose exec web` را نیز به دستوراتمان اضافه کنیم.

```bash
$ docker-compose exec web python manage.py check --deploy
System check identified some issues:

WARNINGS:
...
System check identified 5 issues (0 silenced).

```

چقدر خوب! یک لیست توصیفی و طولانی از مشکلات که باید قبل از دیپلوری کردن پروژه کتاب‌فروشی رفع کنیم


## docker-compose-prod.yml 
درنهایت،‌تنظیمات ما برای محیط توسعه  (development) و محصول (production) متفاوت  هست. ما در حال حاضر، تنظیمات را در فصل ۸ انجام دادیم. اگر یادتون باشه متغییر های محلی (environment variables) را برای SECRET_KEY، DEBUG و پایگاه داده اضافه کردیم. اما مقادیری برای prodduction تنظیم نکردیم یا راهی موثر برای تغییر بین محیط توسعه و محصول ارائه نکردیم.

راه  های زیادی برای برخورد با این چالش وجود دارد.باتوجه به اینکه قرار است در Heroku استقرار دهیم، رویکرد ما ایجاد فایل *docker-compose-prod.yml* است که به واسطه آن می‌توانیم محیط محصول رو تست  کنیم و همچنین میتوانیم بصورت دستی متغییرهای محلی به محیط محصول اضاافه کنیم.

```bash
$ touch docker-compose-prod.yml
```

بطور پیشفرض، گیت تمامی فایل ها و پوشه ها را در پروژه ما دنبال میکند. ما نمی‌خواهیم این فایل جدید را دنبال کند،‌چون حاوی اطلاعات مهم و حساسی هست. راه حل آن ایجاد فایل جدید به نام *.gitignore* است که درون آن باید نام فایل ها و پوشه  هایی که مایلیم توسط گیت  دنبال **نشود** قرار دهیم.

یک فایل جدید ایجاد میکنیم.
```bash
$ touch .gitignore
```

تنها فایل خود را به آن اضافه میکنیم

**.gitignore**
```bash
docker-compose-prod.yml
__pycache__/
db.sqlite3
.DS_Store # Mac only
```

اگر کنجکاو هستید، گیت‌هاب یک فایل رسمی برای [python gitignore](https://github.com/github/gitignore/blob/master/Python.gitignore) دارد که شامل تنظیمات اضافی ارزشمندی هست (برای جستجو) 

اگر دوباره دستور `git status` را اجرا کنید فایل *docker-compose-prod.yml* را مشاهده نخواهید کرد، با اینکه هنوز در پروژه شما قرار دارد. دقیقا همان چیزی که ما می‌خواستیم!

حالا، محتویات فایل docker-compose.yml را در docker-compose-prod.yml کپی می‌کنیم.

**docker-compose-prod.yml**
```yaml
version: '3.8'
services:
  web:
    build: .
    command: python /code/manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/code
    ports:
      - 8000:8000
    depends_on:
      - db
    environment:
      - "DJANGO_SECRET_KEY=)*_s#exg*#w+#-xt=vu8b010%%a&p@4edwyj0=(nqq90b9a8*n"
      - "DJANGO_DEBUG=True"
  db:
    image: postgres:11
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - "POSTGRES_HOST_AUTH_METHOD=trust"
  volumes:
    postgres_data:
```

برای اجرای فایل جدید، داکر را با فلگ -f ریستارت کنید تا فایل [کامپوز جایگزین]((https://docs.docker.com/compose/reference/‌))  انتخاب شود.

```bash
$ docker-compose down
$ docker-compose -f docker-compose-prod.yml up -d --build
$ docker-compose exec web python manage.py migrate
```


### XSS (Cross Site Scripting)

<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Cross-site scripting (XSS)</a> این یک حمله کلاسیک دیگر است که زمانی اتفاق می افتد که مهاجم (attacker) قادر است تکه های کوچکی از کد را به صفحات مشاهده شده توسط افراد دیگر, تزریق کند. این کد ، معمولاً به زبان جاوا اسکریپت است و در صورت ذخیره در پایگاه داده ، بازیابی شده و برای سایر کاربران نمایش داده می شود .
  
  برای مثال : فرمی که برای نوشتن بررسی (نقد) کتاب استفاده می شود را در نظر بگیرید . چه می شود اگر به جای تایپ کردن , “این کتاب عالی بود”  کاربر یک چیزی را با جاوااسکریپ تایپ کند ؟ برای مثال , ```<script>alert('hello');</script>``` .اگر این اسکریپ در دیتابیس ذخیره میشد صفحه هر کاربری یک `alert` با عنوان `hello` به وجود می آمد . در حالی که این مثال خواص بیشتر آزار دهنده است تا خطرناک , سایتی که در مقابل حمله `XSS` آسیب پذیر است بسیار خطرناک است زیرا هر کاربر مخرب میتواند هر  جاوا اسکرییپتی را در صفحه قرار دهد , از جمله کد جاوااسکریپتی که میتواند اطلاعات کاربران ناشناس رو هم بدزدد . 
  
 برای جلوگیری از حمله `XSS` قالب های جنگو به صورت خودکار <a href="https://docs.djangoproject.com/en/3.1/ref/templates/language/#automatic-html-escaping">automatically escape</a> از کاراکتر های خاصی که به طور بالقوه خطرناک هستند از جمله : براکت ها `(< و >)` , سینگل کوت `(single quotes) ' ` , دابل کوت `(double quotes) " ` و علامت `&` دوری می کند . مواردی وجود دارد که ممکن است بخواهید به صورت خودکار <a href="https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#std:templatetag-autoescape">autoescape off</a>  کنید اما باید با احتیاط زیاد انجام شود .
  
   این <a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md">OWASP’s XSS Cheat Sheet</a> برای مطالعه بیشتر توصیه می شود .

### Cross-Site Request Forgery (CSRF)
  
این <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross-Site Request Forgery (CSRF)</a> سومین نوع عمده حمله است اما عموما نسبت به تزریق sql (SQL Injection) یا حمله XSS کمتر شناخته شده است . این حمله اساسا از اعتماد سایت به مرورگر کاربر استفاده می کند .
  
زمانی که کاربر وارد یک سایت می شود , اجازه دهید آن را یک سایت بانکی برای اهداف تصاویر سازی بنامیم , سرور `session token` را برای آن کاربر ارسال می کند . هدر های  HTTP در آینده شامل همه ی request ها و احراز هویت های کاربر می شود . اما اگر یک بازیگر مخرب (هکر) به نحوی به `session token` دسترسی پیدا کند چه اتفاقی می افتد ؟
  
برای مثال , کاربری را در نظر بگیرید که در یک تب مرورگر به بانک خود وارد می شود . سپس آنها در یک تب دیگر ایمیل شان را باز می کنند و روی یک email link که از طرف یک بازیگر مخرب (هکر) است کلیک می کنند . این لینک قانونی به نظر می رسد ,
اما در واقع به بانک کاربر اشاره می کند که هنوز در آن login است ! بنابرابن به جای ترک کردن کامنت وبلاگ در این سایت جعلی , در پشت صحنه , از اطلاعات کاربری برای انتقال پول از حساب آنها به حساب هکر ها استفاده می شود .
  
در عمل روش های زیادی برای به دست آوردن اعتبار کاربر از طریق حمله CSRF وجود دارد , نه فقط لینک ها,
حتی form های پنهان , برچسب های مخصوص عکس , و حتی request های AJAX .
  
جنگو <a href="https://docs.djangoproject.com/en/3.1/ref/csrf/#how-it-works">CSRF protection</a> با قرار دادن secret key رندوم به عنوان کوکی از طریق <a href="https://docs.djangoproject.com/en/3.1/ref/middleware/#django.middleware.csrf.CsrfViewMiddleware">CSRF
Middleware</a> و در فرم ها از طریق تمپلیت تگ (template tag) <a href="https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#csrf-token">csrf_token</a> محافظت می کند . سایت تیم سوم به کوکی های کاربر دسترسی نخواهد داشت بنابراین هرگونه مغایرت بین دو کلید باعث ارور می شود .
  
جنگو امکان سفارشی سازی را مثل همیشه می دهد : شما میتوانید middleware CSRF رای غیر فعال کنید و از تمپلیت تگ (template tag) <a href="https://docs.djangoproject.com/en/3.1/ref/csrf/#django.views.decorators.csrf.csrf_protect">()csrf_protect</a> در view های خاص استفاده بکنید . با این حال این مرحله را با نهایت احتیاط انجام دهید .
  
این OWASP <a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.md">CSRF Cheat Sheet</a> نگاه جامعی به موضوع ارائه می دهد. تغریبا همه ی سایت های اصلی در مقاطعی از زمان قربانی حملات CSRF شده اند . 
  
یک قانون کلی خوب این است که هر گاه در سایت خود یک فرمی دارید , فکر کنید که آیا به تک csrf_token نیاز دارید . بیشتر مواقع به آن نیاز دارید !

  
</div>
  
=======
</div>
