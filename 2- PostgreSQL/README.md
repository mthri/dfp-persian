<div>

<h1 dir="rtl">فصل دوم : PostgreSQL</h1>

<p dir="rtl">
یکی از تفاوت های اصلی بین یک اپلیکیشن ابتدایی و یک اپلیکیشن آماده به کار(production-ready) جنگو، در دیتابیس های آنان است.  
جنگو بدلیل راحت بودن، سریع بودن و file-based بودن SQLite، از این دیتابیس بصورت پیشفرض برای توسعه ی محلی (local development) بهره می برد و آن را به گزینه ی مناسبی تبدیل می کند. علاوه بر آن،این دیتابیس نیاز به هیچ گونه نصب و پیکربندی ندارد.
</p>

<p dir="rtl">
هرچند این دیتابیس معایب خاص خود را دارد. بطور کلی، SQLite دیتابیس مناسبی برای سایت های رده بالا و حرفه ای نیست. اما برای پیاده کردن ایده های اولیه این دیتابیس می تواند پاسخ گو باشد.بطور کلی SQLite بصورت خیلی کم و محدود برای پروژه های بزرگ مورد استفاده قرار می گیرد.
</p>

<p dir="rtl">
جنگو چهار دیتابیس را پشتیبانی می کند: SQLite, PostgreSQL, MySQL و Oracle.ما در این کتاب از PostgreSQL بدلیل معروف بودن آن استفاده خواهیم کرد. زیبایی Django ORM در آن است که اگر حتی از Oracle یا MySQL به جای PostgreSQL استفاده کنیم؛ تفاوتی در کد ما ایجاد نمی کند. Django ORM  کار ترجمه کد از زبان برنامه نویسی پایتون به زبان دیتابیس ها را به راحتی مدیریت می کند و این بسیار شگفت انگیز است.
</p>

<p dir="rtl">
چالشی که این سه دیتابیس  برای ما ایجاد می کنند این است که اگر بخواهید یک production environment را بر روی کامپیوتر خود(local computer) ایجاد کنید؛ باید هر کدام از این دیتا بیس ها  را نصب  و بصورت محلی(local) آن ها را اجرا کنید و ما دقیقا می خواهیم همین عمل را انجام دهیم. در حالی که جنگو جزییات سوییچ بین دیتابیس ها را مدیریت می کند اما زمانی که شما از SQLite برای توسعه ی محلی (local development) و از دیتابیسی دیگر برای محصول نهایی استفاده می کنید؛ممکن است به باگ های خیلی کوچک و اجتناب ناپذیر برخورد کنید که پیدا کردن و رفع آن ها ممکن است شما را به دردسر بیندازد. بنابراین استفاده از یک دیتابیس هم برای توسعه ی محلی و هم برای محصول نهایی راه حل بهتری است.
</p>

<p dir="rtl">
در این فصل ابتدا ما یک پروژه ی جنگو را با استفاده از دیتابیس SQLite توسعه می دهیم و سپس بر روی مباحث Docker و PostgreSQL  سوییچ می کنیم.
</p>

<h2 dir="rtl">شروع به کار</h2>
<p dir="rtl">
ابتدا با استفاده از command line بر روی پوشه ی code در desktop سوییچ کنید. شما این کار را می توانید با دو روش انجام دهید.یا با تایپ کردن .. cd  می توانید از Desktop/code/hello به  Desktop/code هدایت شوید و  یا با تایپ 
 /cd ~/Desktop/code می توانید به آدرس مورد نظرتان هدایت شوید. سپس یک directory به اسم postgresql بسازید.
</p> 

**Command Line**
```
$ cd  ..
$ mkdir postgresql && cd postgresql
```
  
<p dir="rtl">
حالا جنگو را نصب کنید،  shellرا راه اندازی کنید و یک پروژه ی کوچک جنگو به نام postgresql_project  بسازید. یادتان باشد که . را در آخر command وارد کنید.  
</p>

**Command Line**
```
$ pipenv install django==2.2.7
$ pipenv shell
(postgresql) $ django-admin startproject postgresql_project .
```
<p dir="rtl">
حالا می توانیم دیتابیس را migrate کنیم تا آن را راه اندازی نماییم و سپس با استفاده از runserver سرور محلی (local server) راه اندازی کنیم. 
</p>

<blockquote dir="rtl">
به طور کلی، من اجرای migrate را بر روی پروژه های جدید پیشنهاد نمی کنم؛ مگر این که مدل اختصاصی user پیکربندی شده باشد. در غیر این صورت، جنگو، دیتابیس را به مدل داخلی user  متصل می کند که در این صورت اصلاح و تغییر آن در ادامه ی این پروژه، کار دشوار و پیچیده ای خواهد بود. این مبحث را بصورت جزیی تر در فصل 3 بیان خواهیم کرد. چون هدف اصلی ما در این فصل صرفا پیاده سازی هدفمان می باشد؛ بنابراین استفاده از مدل پیش فرض user یک استثنا می باشد.
</blockquote>
  
**Command Line**
```
(postgresql) $ python manage.py migrate
(postgresql) $ python manage.py runserver
```

<p dir="rtl">
اگر دستورات به درستی اجرا شوند، شما به آدرس http://127.0.0.1:8000/  در مرورگرتان هدایت می شوید.شاید نیاز باشد که شما حداقل یک بار صفحه را ریفرش کنید اما بعد از این کار، شما باید با صفحه ی خوش آمد گویی جنگو مواجه شوید.
</p>
  
<p dir="rtl">
سرور محلی  (local server) را با control + c متوقف کنید و سپس با دستور ls همه ی فایل ها و directory ها را لیست کنید.
</p>
 
**Command Line**
```
(postresql) $ ls
Pipfile Pipfile.lock db.sqlite3 manage.py postgresql_project.
```

</div>
